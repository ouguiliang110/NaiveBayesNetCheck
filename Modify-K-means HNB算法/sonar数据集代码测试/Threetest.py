import numpy as np
import math


# 连续型数据分类用正态分布公式
def getPro(theData, mean, var):
    pro = 1 / (math.sqrt(2 * math.pi) * math.sqrt(var)) * math.exp(-(theData - mean) ** 2 / (2 * var))
    return pro


def getRandom(num):
    Ran = np.random.dirichlet(np.ones(num)*100, size = 1)
    Ran = Ran.flatten()
    return Ran


'''
def CountP1(test):
    sum=1
    for i in range(0,60):
       sum*=getPro(test[i],
def CountP2(test):
    sum=1
    for i in  range(0,60):
        sum*=getPro(())
'''
X = np.loadtxt('[023]sonar(0-1).txt')
# 其中有97
m = 60  # 属性数量
n = 208  # 样本数目
K = 2  # 类标记数量
# 主要过程：分组
Class1=97
Class2=111
# 随机产生多少个和为1的随机数W
G1=[15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 33, 34, 35, 36]
G2=[5, 14, 23, 26, 27, 28, 29, 30, 31, 37, 38, 39]
G3=[0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 32, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]
W=getRandom(m*2)*100
print(W)
W=[0.11189183535517222,0.8716247334930967,2.1123084431324237,0.3529460931577454,0.7846145953348748,0.1063995547023043,1.1583433950433353,1.4213831065469889,0.482255618802095,1.2648618192432646,1.613314155885702,0.9335330850625729,2.2370658211077337,0.942783419687844,0.03129261374305648,0.9730432735571887,2.828359763661604,0.6622622989996702,0.850092985547919,0.12050811524172281,1.9993618747575703,0.24158366010631727,1.9112257217386783,0.013551591483180204,0.7310764463347408,2.9360927561898835,0.9246430560071524,0.036054653903609804,0.4498023676472909,0.3407401304508234,0.2678599525680153,1.475424599103482,0.0855970487962855,1.0440096777045493,0.643825205635015,1.092360806747806,0.2460119347390215,1.1163436686691848,0.7605522691168067,0.09879609270069213,0.39360819793703444,0.091904934596321,1.5759089057268991,1.577769417917524,1.7797002697028255,1.2520195708940771,0.009971448313153717,0.035793509309264164,0.166607343549372,0.18863126642307315,0.3856064517765903,0.13726514384704905,0.8727145822960777,1.180797287335791,0.13783526066558682,1.4040242960943723,0.18714408374749703,2.15415997951038,0.7254155002857332,0.11186751048900126,0.0072390614267885175,0.5941524294701535,0.4829236480711387,0.05560148523718871,0.0629371166454679,0.2407348977670022,0.3345474367230721,1.171200922665871,0.715208497978253,0.8334593070978465,0.015605387580861043,0.7095710128357261,0.5793046475772649,0.2588756968148946,0.43625536329736475,1.8871300256061514,1.2616010065954464,0.11750615340682546,0.01223131616857206,0.9031903733211848,0.5019481117812422,0.21169394520611376,0.04468740653334484,1.767722018949889,1.0381301358212,1.5589306430845735,0.5086039891668231,3.2189321974383636,0.2441994307659006,0.5549277720185101,0.8585848082153007,0.884165016538152,0.08464157043521604,0.7337234045961103,0.024751904647842535,0.4518634610055614,0.8033514149586896,0.19228153998556016,2.1744654234373693,0.951335867326136,0.42271176261452753,1.5992841281056196,2.688500189779021,0.8791560591333488,0.9691427888285564,0.3388855526798935,0.9671816329141933,0.5083155989063082,0.7882975489042906,0.8794725698332575,1.0813713753959846,1.776848194624537,1.266702933947496,1.2317283699816561,0.593161149668021,1.147170713680017,0.33632346034319727,2.8578300598518362,0.7586633265170861,0.7784935339681436]
#求类1的分组情况
NewArray = np.ones((97, 4))
# 第0组
W1 = W[0:14]
for i in range(0, 97):
    add1 = 0
    for j in range(0,14):
        add1+=W1[j] * X[i, G1[j]]
    NewArray[i][0]=add1
# 第1组
W2 = W[14:26]
for i in range(0, 97):
    add2 = 0
    for j in range(0,12):
        add2+=W2[j] * X[i, G2[j]]
    NewArray[i][1]=add2
# 第2组
W3 = W[26:60]
for i in range(0, 97):
    add3 = 0
    for j in range(0,34):
        add3+=W3[j] * X[i, G3[j]]
    NewArray[i][2]=add3

#print(NewArray)

#求类2的分组情况
NewArray1 = np.ones((111, 4))*2
# 第0组
W4 = W[60:74]
for i in range(Class1, n):
    add1 = 0
    for j in range(0,14):
        add1+=W4[j] * X[i, G1[j]]
    NewArray1[i-Class1][0]=add1
# 第1组
W5 = W[74:86]
for i in range(Class1, n):
    add2 = 0
    for j in range(0,12):
        add2+=W5[j] * X[i, G2[j]]
    NewArray1[i-Class1][1]=add2
# 第2组
W6 = W[86:120]
for i in range(Class1, n):
    add3 = 0
    for j in range(0,34):
        add3+=W6[j] * X[i, G3[j]]
    NewArray1[i-Class1][2]=add3

#print(NewArray1)

#合并两个数组，得到真正的合并数据结果
NewArray=np.vstack((NewArray,NewArray1))
print(NewArray)



# 去掉类标记
NewArray = np.delete(NewArray, 3, axis = 1)

# 取训练集,验证集和测试集5:2:3比例
# 训练集
trainSet1=NewArray[0:47, :]
trainSet2=NewArray[97:152, :]
trainingSet=np.vstack((trainSet1, trainSet2))
# print(trainingSet)
# 验证集
valSet1=NewArray[47:67, :]
valSet2=NewArray[152:174, :]

# 训练集
testSet1=NewArray[67:97, :]
testSet2=NewArray[174:208, :]
testSet=np.vstack((testSet1, testSet2))
# print(testSet)

# 求各类对应属性的均值和方差
Mean1 = np.mean(trainSet1, axis = 0)
print(Mean1)
Mean2 = np.mean(trainSet2, axis = 0)
var1 = np.var(trainSet1, axis = 0)
var2 = np.var(trainSet2, axis = 0)

# 先求P(C)
Pro1=(47 + 1) / (102 + 2)
Pro2=(55 + 1) / (102 + 2)
# print(Pro1)
# print(Pro2)

# 本次代码主要内容是这个，求P(Ai|C)

# 统计正确数量和计算准确率
add = 0
for i in range(0, 47):
    sum = 1
    for j in range(0, 3):
        sum *= getPro(trainSet1[i][j], Mean1[j], var1[j])
    sum1 = 1
    for j in range(0, 3):
        sum1 *= getPro(trainSet1[i][j], Mean2[j], var2[j])
    print(sum)
    print(sum1)
    if Pro1*sum > Pro2*sum1:
        add += 1
    elif Pro1*sum < Pro2*sum1:
        add += 0
print("第一类正确数量(总数30)：")
print(add)
add1 = 0
for i in range(0, 55):
    sum = 1
    for j in range(0, 3):
        sum *= getPro(trainSet2[i][j], Mean2[j], var2[j])
    sum1 = 1
    for j in range(0, 3):
        sum1 *= getPro(trainSet2[i][j], Mean1[j], var1[j])
    if Pro2*sum > Pro1*sum1:
        add1 += 1
    elif Pro2*sum < Pro1*sum1:
        add1 += 0
print("第二类正确数量(总数34)：")
print(add1)
# 准确率
print("accuracy:{:.2%}".format((add + add1) / 102))

