import numpy as np
import math
from sklearn.naive_bayes import GaussianNB

# 连续型数据分类用正态分布公式
def getPro(theData, mean, var):
    pro = 1 / (math.sqrt(2 * math.pi) * math.sqrt(var)) * math.exp(-(theData - mean) ** 2 / (2 * var))
    return pro


def getRandom(num):
    Ran = np.random.dirichlet(np.ones(num)*2, size = 1)
    Ran = Ran.flatten()
    return Ran


'''
def CountP1(test):
    sum=1
    for i in range(0,60):
       sum*=getPro(test[i],
def CountP2(test):
    sum=1
    for i in  range(0,60):
        sum*=getPro(())
'''

X = np.loadtxt('[024]SPECTF(0-1).txt')
# 其中有97
m = 44  # 属性数量
n = 267  # 样本数目
T = 3
K = 2  # 类标记数量
Class1 = 212
Class2 = 55
# 主要过程：分组

# 随机产生多少个和为1的随机数W
G1 = [6, 8, 10, 11, 16, 25, 31, 33, 34, 35, 38, 40, 41, 42]
G2 = [0, 3, 4, 9, 12, 14, 19, 20, 23, 24, 26, 28, 29, 32, 43]
G3 = [1, 2, 5, 7, 13, 15, 17, 18, 21, 22, 27, 30, 36, 37, 39]
W=getRandom(m*2)*100
print(W)
W=[0.008280534289155525,0.14162285634428698,0.13625381666781516,0.011262374628186874,0.01704429768280945,0.27662294851725716,0.026017830531102692,0.06649980159329526,0.03344995001567173,0.47042722372918366,0.0008490679699961255,0.005555103904828509,0.0633361041826219,0.003292755218386452,0.23204778700341114,0.2965497932873122,0.13994722430740228,0.10284631953271145,0.0033864509424532314,0.4952079642183561,0.0005609431798869336,0.01559114816440197,0.059700423073491146,0.08351606622983004,0.18696646226512334,0.004262323788390185,0.12942621946631871,0.2569333442336676,0.04464337468093291,0.0022619842969586806,0.024995252237866486,0.2116079613341752,0.13379423558616463,0.10560079206452869,0.017399887810828553,0.0011923167734391835,0.07157295428768157,0.031964910722531936,0.04405265588349093,0.1738367127619581,0.03588824247135234,0.07707642782706967,0.10958025856313816,0.004776133975948986,0.3731542138754041,0.032562553958903215,0.009854043269011344,0.010093938795181022,0.11642889780188097,0.13779388412238402,0.019516792925421713,0.05700922063294425,0.2602228114765002,0.23083035898341836,0.01099430313061354,0.1287503878595336,0.17302832675746777,0.1766762754607472,0.005193107039226793,0.0038877919190687025,0.14396756786832593,0.3185537054978565,0.33405488389456184,0.03678970558664862,0.3039983701447362,0.14968139669037475,0.16281344926874974,0.07336182454994147,0.12211703487032438,0.09595759336792174,0.012821237929069878,0.3103151722588788,0.05383261791257486,0.27115230725386247,0.5761522234722373,0.04216058683050645,0.11240015281326407,0.09473646074109283,0.016125145225630508,0.10612953040744683,0.052433186404943634,0.12490612308381936,0.016322257169111332,0.1329324443058916,0.002198719493683483,0.03962051332957363,0.0401871545190599,0.15058049085679026]

print(W)
# 求类1的分组情况
NewArray = np.ones((Class1, T+1))
# 第0组
W1 = W[0:14]
for i in range(0, Class1):
    add1 = 0
    for j in range(0, 14):
        add1 += W1[j] * X[i, G1[j]]
    NewArray[i][0] = add1
# 第1组
W2 = W[14:29]
for i in range(0, Class1):
    add2 = 0
    for j in range(0, 15):
        add2 += W2[j] * X[i, G2[j]]
    NewArray[i][1] = add2
# 第2组
W3 = W[29:44]
for i in range(0, Class1):
    add3 = 0
    for j in range(0, 15):
        add3 += W3[j] * X[i, G3[j]]
    NewArray[i][2] = add3

# print(NewArray)

# 求类2的分组情况
NewArray1 = np.ones((Class2, T+1)) * 2
# 第0组
W4 = W[44:58]
for i in range(Class1, n):
    add1 = 0
    for j in range(0, 14):
        add1 += W4[j] * X[i, G1[j]]
    NewArray1[i-Class1][0] = add1
# 第1组
W5 = W[58:73]
for i in range(Class1, n):
    add2 = 0
    for j in range(0, 15):
        add2 += W5[j] * X[i, G2[j]]
    NewArray1[i-Class1][1] = add2
# 第2组
W6 = W[73:88]
for i in range(Class1, n):
    add3 = 0
    for j in range(0, 15):
        add3 += W6[j] * X[i, G3[j]]
    NewArray1[i-Class1][2] = add3
# print(NewArray1)

# 合并两个数组，得到真正的合并数据结果
NewArray = np.vstack((NewArray, NewArray1))
print(NewArray)
Y=NewArray[:,T]
# 去掉类标记
NewArray = np.delete(NewArray, T, axis = 1)

# 取训练集和测试集7：3比例
Data1 = NewArray[0:147, :]
Data2 = NewArray[212:247, :]
trainingSet = np.vstack((Data1, Data2))
# print(trainingSet)
testSet1 = NewArray[147:212, :]
testSet2 = NewArray[247:267, :]
# testSet = np.vstack((testSet1, testSet2))
# print(testSet)



# 通过朴素贝叶斯算法得到分类器的准确率
clf=GaussianNB()
clf.fit(NewArray,Y)
C1=clf.predict(Data1)
add=sum(C1==1)
print(add)
C2=clf.predict(Data2)
add1=sum(C2==2)
print(add1)
print("accuracy:{:.2%}".format((add+add1)/182))

