import numpy as np
import math
from sklearn.naive_bayes import GaussianNB

# 连续型数据分类用正态分布公式
def getPro(theData, mean, var):
    pro = 1 / (math.sqrt(2 * math.pi) * math.sqrt(var)) * math.exp(-(theData - mean) ** 2 / (2 * var))
    return pro


def getRandom(num):
    Ran = np.random.dirichlet(np.ones(num)*100, size = 1)
    Ran = Ran.flatten()
    return Ran

def getK(Data, X):
    add = 0
    n = Data.shape[0]
    for i in range(0, n):
        add += 1 / math.sqrt(2 * math.pi * n) * math.exp(-(np.sum(np.square(Data[i] - X)) * n / 2))
    return add

'''
def CountP1(test):
    sum=1
    for i in range(0,60):
       sum*=getPro(test[i],
def CountP2(test):
    sum=1
    for i in  range(0,60):
        sum*=getPro(())
'''
X = np.loadtxt('[023]sonar(0-1).txt')
# 其中有97
m = 60  # 属性数量
n = 208  # 样本数目
K = 2  # 类标记数量
T=3
# 主要过程：分组
Class1=97
Class2=111
# 随机产生多少个和为1的随机数W
G1=[15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 33, 34, 35, 36]
G2=[5, 14, 23, 26, 27, 28, 29, 30, 31, 37, 38, 39]
G3=[0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 32, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]
W=getRandom(m*2)*100
print(W)
W=[0.06014368548560663,0.09459948320494599,0.43790214296493596,0.071094969067553,0.8199278171144633,1.2457908002423193,0.3455412202415834,0.1960196053439687,1.2524987933883798,0.5471582011587576,1.8924081827317367,2.3683648811130262,0.060386909971337104,0.8620516488585129,0.570611949394576,0.08339598414893608,0.30581502515016973,0.2040804110519832,0.15089615467960601,0.22536771034643485,1.547576888901062,0.245014957831757,0.6898101387193388,0.2175660906158566,0.2138664925319783,0.4675267897693453,0.3155609736878182,0.20648551980490568,0.10797608077053399,0.3794280382455548,1.378067718166998,1.2950668999565875,1.0648422659387775,1.9299872221611531,2.212134696957412,0.24712764664882458,0.8845304021750325,1.2113986588327472,0.008484942811730255,0.4586707487618649,2.0190985698104615,0.8124099112684958,0.06215450652680201,0.44402163627409097,0.5439594032882005,0.7042172829163035,0.3015075655237871,0.009034048861155197,0.24207015644665386,2.5925177191548276,0.7054086495620546,0.4537321476764191,1.8838563652353453,1.2552848512757346,1.2397039449969791,0.6392936561664199,0.668055637253863,1.0996877359040012,0.20482682265898453,1.395814675127141,0.4001769035007391,0.33657118893736565,2.9523831858764518,0.26190020509026124,1.147589619964089,0.5264326045350971,0.6590405297408914,0.3423817284210904,0.5936642897069644,0.7131838130537786,1.136115367031947,0.10184451164606989,1.247388748110807,0.18409144121676457,3.9555721781042794,0.6106103916018653,1.1192645469873133,2.9165084051863643,0.18279996510694166,0.10896274705423008,1.2923960151508846,0.37971204179890644,2.1408537213577845,1.6218985240892128,1.0953013192765333,1.8912858713686729,0.07105280837337775,0.08537135288376153,1.0077223207106882,1.1025963097135636,1.0622800262776777,0.5249458596315599,1.4381949856828846,3.5981728285723387,0.07970369358905918,0.057008110860779976,0.8394487615547567,0.4066905750976956,0.46766247110875575,0.16771895982927118,0.14720217818714104,0.34935458425319244,0.03511950942012886,0.5714917967696505,0.12301617110625379,1.15631689082847,2.098055436885777,1.5842633021909664,0.646052919689663,1.7159808452132688,0.897015846645353,0.4508629655420005,0.24357086953418067,1.533036794827312,0.15907608756883804,0.8983562272645437,1.7101415967744635,0.08437753947686145,2.284222773847301,0.3341527012973833]
#求类1的分组情况
NewArray = np.ones((97, 4))
# 第0组
W1 = W[0:14]
for i in range(0, 97):
    add1 = 0
    for j in range(0,14):
        add1+=W1[j] * X[i, G1[j]]
    NewArray[i][0]=add1
# 第1组
W2 = W[14:26]
for i in range(0, 97):
    add2 = 0
    for j in range(0,12):
        add2+=W2[j] * X[i, G2[j]]
    NewArray[i][1]=add2
# 第2组
W3 = W[26:60]
for i in range(0, 97):
    add3 = 0
    for j in range(0,34):
        add3+=W3[j] * X[i, G3[j]]
    NewArray[i][2]=add3

#print(NewArray)

#求类2的分组情况
NewArray1 = np.ones((111, 4))*2
# 第0组
W4 = W[60:74]
for i in range(Class1, n):
    add1 = 0
    for j in range(0,14):
        add1+=W4[j] * X[i, G1[j]]
    NewArray1[i-Class1][0]=add1
# 第1组
W5 = W[74:86]
for i in range(Class1, n):
    add2 = 0
    for j in range(0,12):
        add2+=W5[j] * X[i, G2[j]]
    NewArray1[i-Class1][1]=add2
# 第2组
W6 = W[86:120]
for i in range(Class1, n):
    add3 = 0
    for j in range(0,34):
        add3+=W6[j] * X[i, G3[j]]
    NewArray1[i-Class1][2]=add3

#print(NewArray1)

#合并两个数组，得到真正的合并数据结果
NewArray=np.vstack((NewArray,NewArray1))
print(NewArray)

Y=NewArray[:,3]

# 去掉类标记
NewArray = np.delete(NewArray, 3, axis = 1)

# 取训练集和测试机7：3比例
Data1 = NewArray[0:70, :]
Data2 = NewArray[97:174, :]
trainingSet = np.vstack((Data1, Data2))
#print(trainingSet)
testSet1 = NewArray[70:97, :]
testSet2 = NewArray[174:208, :]
testSet = np.vstack((testSet1, testSet2))
#print(testSet)

'''
# 求各类对应属性的均值和方差
Mean1 = np.mean(trainSet1, axis = 0)
print(Mean1)
Mean2 = np.mean(trainSet2, axis = 0)
var1 = np.var(trainSet1, axis = 0)
var2 = np.var(trainSet2, axis = 0)
'''



# 本次代码主要内容是这个，求P(Ai|C)

# 统计正确数量和计算准确率
clf=GaussianNB()
clf.fit(NewArray,Y)
C1=clf.predict(Data1)
add=sum(C1==1)
print(add)
C2=clf.predict(Data2)
add1=sum(C2==2)
print(add1)
print("accuracy:{:.2%}".format((add+add1)/147))


