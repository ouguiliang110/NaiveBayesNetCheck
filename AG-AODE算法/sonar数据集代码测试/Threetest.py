import numpy as np
import math


# 连续型数据分类用正态分布公式
def getPro(theData, mean, var):
    pro = 1 / (math.sqrt(2 * math.pi) * math.sqrt(var)) * math.exp(-(theData - mean) ** 2 / (2 * var))
    return pro


def getRandom(num):
    Ran = np.random.dirichlet(np.ones(num)*100, size = 1)
    Ran = Ran.flatten()
    return Ran


'''
def CountP1(test):
    sum=1
    for i in range(0,60):
       sum*=getPro(test[i],
def CountP2(test):
    sum=1
    for i in  range(0,60):
        sum*=getPro(())
'''
X = np.loadtxt('[023]sonar(0-1).txt')
# 其中有97
m = 60  # 属性数量
n = 208  # 样本数目
K = 2  # 类标记数量
# 主要过程：分组
Class1=97
Class2=111
# 随机产生多少个和为1的随机数W
G1=[15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 33, 34, 35, 36]
G2=[5, 14, 23, 26, 27, 28, 29, 30, 31, 37, 38, 39]
G3=[0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 32, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]
W=getRandom(m*2)*100
print(W)
W=[0.11587261796851783,0.8772486543579905,0.831213600272187,1.3378888963547455,2.7768677294177495,0.2177426874589024,0.0886342228791287,0.1956095321174025,0.6283778293075081,0.5636658673495041,1.2065062528280355,0.528063355601298,0.638818527451548,0.28498106162729137,0.3996810600703763,0.05348997795558448,0.2344769976935553,0.06334010096000756,1.1981076006051812,0.8273123429390702,0.17220647887245558,0.02596747390574112,1.3175023988860906,0.048982558566943106,0.2833157259456117,0.5252325221219107,1.0938649586960127,0.23427238194444355,0.31034075752378043,0.07974738120997305,0.48951821413347457,0.00604061157628431,0.74040526979234,0.23577829827851263,1.6256408283949295,1.1172467896692118,1.1655587853411495,1.5451232527855943,1.4787679624038172,0.4684688104904124,0.23762510345463156,0.5431946374790947,0.45350512006717797,0.2723164141656487,0.6765722848994035,0.4676175529709196,0.4572021309844433,1.877563155826742,0.09727110019442896,3.3697938407063073,0.9999663239920829,0.8490196455657656,0.03942797438092138,0.2644607484163524,3.3059022296599316,0.014520388683054336,2.08971518885832,0.6639694104925022,1.3328574908421331,0.030549470062217855,1.5592911700957997,1.3744069251902717,4.267719645856082,0.38799487001852484,0.022182201885220146,0.9282329121973789,0.19071601801105453,1.6890619525387462,0.20374376447974316,0.01824863291070966,0.1921767763403221,0.5104039577402555,0.6584831782126964,0.3789881954841371,0.19237776517538413,1.8184324718130553,2.3710518117753394,0.8924555934007175,1.2345166395395184,1.195255290668876,2.5036243102145845,2.170605587914036,0.20413332433505468,0.16705301990782034,1.2140415518925562,1.1570413042611778,1.247425066752514,0.3941799100661188,0.8558931835009861,0.11671963981843422,1.7389231739707949,4.345415817148186,0.7386959852436095,0.43005151300444305,0.08598788303069557,0.1759883937334889,0.25965445251994707,0.8160210622773281,0.23207859281683843,0.24130837921312484,0.22919824745207465,1.7042415175028331,0.3709380540417347,0.6276500401989961,0.9525046172054951,0.4897787365109388,0.5868781129222846,0.3241831207808699,0.33165604491666656,0.4705793973827108,0.4860304178462494,0.3863218021080549,2.9338400472031236,0.09299915969691247,0.04260243726839419,1.2181459797007168,2.5572161340722195,0.10608741024876991,1.8472453029656906,0.9863909075633627]
#求类1的分组情况
NewArray = np.ones((97, 4))
# 第0组
W1 = W[0:14]
for i in range(0, 97):
    add1 = 0
    for j in range(0,14):
        add1+=W1[j] * X[i, G1[j]]
    NewArray[i][0]=add1
# 第1组
W2 = W[14:26]
for i in range(0, 97):
    add2 = 0
    for j in range(0,12):
        add2+=W2[j] * X[i, G2[j]]
    NewArray[i][1]=add2
# 第2组
W3 = W[26:60]
for i in range(0, 97):
    add3 = 0
    for j in range(0,34):
        add3+=W3[j] * X[i, G3[j]]
    NewArray[i][2]=add3

#print(NewArray)

#求类2的分组情况
NewArray1 = np.ones((111, 4))*2
# 第0组
W4 = W[60:74]
for i in range(Class1, n):
    add1 = 0
    for j in range(0,14):
        add1+=W4[j] * X[i, G1[j]]
    NewArray1[i-Class1][0]=add1
# 第1组
W5 = W[74:86]
for i in range(Class1, n):
    add2 = 0
    for j in range(0,12):
        add2+=W5[j] * X[i, G2[j]]
    NewArray1[i-Class1][1]=add2
# 第2组
W6 = W[86:120]
for i in range(Class1, n):
    add3 = 0
    for j in range(0,34):
        add3+=W6[j] * X[i, G3[j]]
    NewArray1[i-Class1][2]=add3

#print(NewArray1)

#合并两个数组，得到真正的合并数据结果
NewArray=np.vstack((NewArray,NewArray1))
print(NewArray)



# 去掉类标记
NewArray = np.delete(NewArray, 3, axis = 1)

# 取训练集,验证集和测试集5:2:3比例
# 训练集
trainSet1=NewArray[0:47, :]
trainSet2=NewArray[97:152, :]
trainingSet=np.vstack((trainSet1, trainSet2))
# print(trainingSet)
# 验证集
valSet1=NewArray[47:67, :]
valSet2=NewArray[152:174, :]

# 训练集
testSet1=NewArray[67:97, :]
testSet2=NewArray[174:208, :]
testSet=np.vstack((testSet1, testSet2))
# print(testSet)

# 求各类对应属性的均值和方差
Mean1 = np.mean(trainSet1, axis = 0)
print(Mean1)
Mean2 = np.mean(trainSet2, axis = 0)
var1 = np.var(trainSet1, axis = 0)
var2 = np.var(trainSet2, axis = 0)

# 先求P(C)
Pro1=(47 + 1) / (102 + 2)
Pro2=(55 + 1) / (102 + 2)
# print(Pro1)
# print(Pro2)

# 本次代码主要内容是这个，求P(Ai|C)

# 统计正确数量和计算准确率
add = 0
for i in range(0, 30):
    sum = 1
    for j in range(0, 3):
        sum *= getPro(testSet1[i][j], Mean1[j], var1[j])
    sum1 = 1
    for j in range(0, 3):
        sum1 *= getPro(testSet1[i][j], Mean2[j], var2[j])
    print(sum)
    print(sum1)
    if Pro1*sum > Pro2*sum1:
        add += 1
    elif Pro1*sum < Pro2*sum1:
        add += 0
print("第一类正确数量(总数30)：")
print(add)
add1 = 0
for i in range(0, 34):
    sum = 1
    for j in range(0, 3):
        sum *= getPro(testSet2[i][j], Mean2[j], var2[j])
    sum1 = 1
    for j in range(0, 3):
        sum1 *= getPro(testSet2[i][j], Mean1[j], var1[j])
    if Pro2*sum > Pro1*sum1:
        add1 += 1
    elif Pro2*sum < Pro1*sum1:
        add1 += 0
print("第二类正确数量(总数34)：")
print(add1)
# 准确率
print("accuracy:{:.2%}".format((add + add1) / 64))

